### 1、安装模式
  分为三种：单主机模式、普通集群模式、镜像集群模式。
  
  单主机模式：rabbitmq运行在一台主机上，生产环境不建议使用该模式，性能有限。如果该台主机down机，整个服务将不可用。
  
  普通集群模式：对于queue来说，消息实体只存在于一个节点上，集群中其他节点仅有相同的元数据，即队列结构。经过B发送给consumer。所以consumer尽量连接每一个节点，从中去消息，即对于同一个逻辑队列，要在多个节点建立queue。否则consumer如果只连接一个节点区消息会造成该节点的性能瓶颈。
  
  该模式存在当其中一个节点故障后，其他节点无法获取到故障节点中还未消费的消息，如果做了消息持久化，必须等待A节点恢复，然后才可以被消费。
  
  镜像集群模式：该模式会把队列结构和消息都存在于多个节点，属于rabbitmq的HA方案。缺点：降低系统性能。
  
  RabbitMQ的集群节点包括内存节点、磁盘节点。顾名思义内存节点就是将所有数据放在内存，磁盘节点将数据放在磁盘。如果在投递消息时，打开了消息的持久化，那么即使是内存节点，数据还是会放在磁盘。原则上一个集群至少有一个磁盘节点。在实际使用中会发现所谓的磁盘节点是只用来存储集群的配置信息，也就是说如果集群中没有磁盘节点，当所有节点关机后集群的配置信息就会丢失。在进行性能测试时两个模式的节点订阅发布消息的性能没有太大差距。

### 2、多节点流量分发
  RabbitMQ集群模式是没有中心节点的，并且在连接集群的时候实际上Consumer是连接其中某一台节点，连接方法和单主机模式一致。
 
  通过负载均衡设备来实现流量分发。可以使用F5硬件负载均衡，如果没有F5的硬件负载均衡设备也可以使用LVS、haproxy等服务，当Consumer连接集群时实际是先经过负载均衡。首先将集群中所以节点的IP放在一个数组中，app在连接RabbitMQ的时候会从数组中随机选择一个IP来连接，然后把连接的节点的IP缓存到服务器，如果连接超时则重新随机选择其他节点来连接。通过这种方式来实现app流量的分发。
 
### 3、普通集群部署
#### 3.1、部署环境
```
操作系统：CentOS Linux release 7.5.1804 (Core)
节点1:192.168.40.102
节点2:192.168.40.105
```
#### 3.2、修改主机名配置
```
vim /etc/hosts
添加内容如下：
192.168.40.102 node-192-168-40-102
192.168.40.105 node-192-168-40-105
```
#### 3.3、同步节点cookie
  rabbitmq依赖于erlang集群工作，所以必须先构建erlang的集群环境。cookie的存放目录为：/var/lib/rabbitmq/.erlang.cookie，权限为400.必须保证所有节点一致。
  
  关于cookie同步以及解析，可参考链接：https://github.com/MorningBorn/document/blob/master/rabbitmq/.erlang.cookie%E6%96%87%E4%BB%B6%E8%A7%A3%E6%83%91.md
  
  此处以192.168.40.102作为基准节点，以此节点的cookie为标准进行同步。在192.168.40.102上执行如下命令：
  ```
  scp /var/lib/rabbitmq/.erlang.cookie root@192.168.40/105:/var/lib/rabbitmq/.erlang.cookie 
  scp /root/.erlang.cookie root@192.168.40/105:/root/ 
  ```
  
  所有节点修改cookie文件权限，命令如下：
  ```
  chmod -R 400 /var/lib/rabbitmq/.erlang.cookie
  chmod -R 400 /root/.erlang.cookie
  ```
#### 3.4、启动服务同时将节点加入集群
  首先启动192.168.40.102上rabbitmq服务，然后将192.168.40.105节点加入192.168.40.102作为集群运行。
  
  在192.168.40.102上执行如下命令：
  ```
  rabbitmq-server -detached
  ```
  
  在192.168.40.105上执行如下命令：
  ```
  rabbitmq-server -detached #以后台模式运行
  rabbitmqctl stop_app #仅停止rabbitmq应用
  rabbitmqctl join_cluster --ram rabbit@node-192-168-40-105 #此处192.168.40.105以ram(内存)运行模式加入集群
  rabbitmqctl start_app #启动rabbitmq应用
  ```
  
  在任意一台上查看集群状态：
  ```
  rabbitmqctl cluster_status
  ```
  
  磁盘节点，join_cluster 命令去掉--ram参数即可。 在RabbitMQ集群里，必须至少有一个磁盘节点存在(磁盘节点用来存储集群状态)。
  
  ### 4、镜像集群
  - **1. 镜像复制模式解析**
 
  |ha-mode  |ha-params   |result   |
  |:------------|:------------|:------------|
  |all  |(absent)不需要参数  |信息映射到所有节点，新节点加入集群也会被映射|
  |exactly|count,需要给出节点个数|集群中节点个数.如果配置参数超过了集群总节点数 默认是all(集群中所有节点).|
  |nodes|node names,需要给出节点名称|指定信息映射到哪些节点|
  
  - **2. 镜像模式命令配置**
  语法：set_policy 策略名称 匹配队列名的正则表达式  被复制的方式(上面的ha-mode和参数)
  
  - **3. 镜像模式举例**
  ha-mode=all：
  ```
  所有名字ha开头的队列都复制到所有的集群主机,策略名称为:ha-all.:
  rabbitmqctl set_policy ha-all "^ha\." '{"ha-mode":"all"}'
  ```
  ha-mode=exactly:
  ```
  所有名字 two.开头的队列随机复制到任意一台集群主机,数量为2,策略名称为ha-two.：
  rabbitmqctl set_policy ha-two "^two\." '{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'
  ```
  
  ha-mode=nodes:
  ```
  所有nodes开头的队列都复制到node2和node3.策略名称:ha-nodes.
  rabbitmqctl set_policy ha-nodes "^nodes\." '{"ha-mode":"nodes","ha-params":["rabbit@node2", "rabbit@node3"]}'
  ```
  
  
haproxy反向代理rabbitmq并开启监控
  ```
  listen stats
   mode http
   bind *:1090
   stats enable
   stats hide-version
   stats uri    /hadmin
   stats auth    admin:admin
   stats admin if TRUE

  listen test_rabbitmq_cluster 0.0.0.0:5672
    mode tcp
    balance roundrobin
    option tcpka
    timeout client 99999m
    timeout server 99999m
    server kvm-dev-mq-redis-192-168-40-102 192.168.40.102:5672 check maxconn 65535 inter 2000 rise 2 fall 3
    server kvm-dev-mq-redis-192-168-40-105 192.168.40.105:5672 check maxconn 65535 inter 2000 rise 2 fall 3
  ```
  
